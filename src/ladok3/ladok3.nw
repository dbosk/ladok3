\chapter{Overview}

This is the documented source code of the LADOK3 API wrapper for Python, the 
package [[ladok3]].
We use the standard structure for the script.
We start with the imports and then our class definitions follow in 
[[<<classes>>]] and some helper functions in [[<<functions>>]].
<<ladok3.py>>=
"""A Python wrapper for the LADOK3 API"""
# -*- coding: utf-8 -*-
import cachetools
import datetime
import functools
import html
import json
import operator
import re
import requests
import urllib.parse
import weblogin.ladok

<<classes>>
<<functions>>
@

We also provide tests for all functionality in [[<<test ladok3.py>>]].
These illustrate how to the [[ladok3]] module and provide testing using 
[[pytest]].
<<test ladok3.py>>=
import json
import ladok3
import os
import weblogin.kth

<<test functions>>
@


\chapter{Accessing LADOK}\label{AccessingLADOK}

To access LADOK we provide a class [[LadokSession]].
An instance of this class provides the [[session]] attribute, which is an 
authenticated session to LADOK's REST API.
It uses the [[requests]] module.

We can use the class as follows.
\inputminted{python}{../examples/example_LadokSession.py}

An alternative way would be to use the general authentication procedure that 
seems to work at most Swedish universities.
\begin{minted}[linenos]{python}
import ladok3

ladok = ladok3.LadokSession("KTH Royal Institute of Technology",
                            vars={"username": os.environ["KTH_LOGIN"],
                                  "password": os.environ["KTH_PASSWD"]},
                            test_environment=True) # for experiments
\end{minted}

This chapter covers how the [[LadokSession]] class work.
The remaining chapters cover what the [[ladok]] object can be used for.
\Cref{StudentClasses} covers how we can work with student data.
\Cref{CourseClasses} covers how we can work with course data.


\section{The [[LadokSession]] class}\label{LadokSession}

There are two categories of functionality that we want from the 
[[LadokSession]] object.
The first is the [[session]] attribute.
This is an active and logged-in session that can be used to query LADOK (REST 
API over HTTPS).
The second is the set of methods to get objects of interest, these methods use 
the [[session]] attribute to query data to create the objects.
We cover the first (the [[session]] attribute) in this section and the second 
(the data methods) in \cref{LadokSession-data-methods}.

We want to provide the attribute [[session]] which is an active and logged-in 
session for querying LADOK.
We must thus handle authentication to LADOK.
The authentication for using LADOK is performed using a university SSO system.
We will use the [[weblogin]] package\footnote{%
  URL: \url{https://github.com/dbosk/weblogin}
} to handle this.
This will guarantee that we're always signed in.
<<classes>>=
class LadokSession:
  """This is an interface for reading and writing data from and to LADOK."""
  def __init__(self, institution, vars=None, autologin_handlers=None,
               test_environment=False):
    """
    Creates a session with LADOK.
    - `institution` is the name (str) of the university that will give a unique 
      match when searching SeamlessAccess.org (see weblogin.ladok.SSOlogin).
    - `vars` is a dictionary that is passed to weblogin.ladok.SSOlogin to 
      supply the login credentials. Usually contains keys 'username' and 
      'password', see weblogin.ladok.SSOlogin documentation for details.
    - `autologin_handlers` is a list of weblogin.AutologinHandler objects 
      specific to the institution. Usually one for the SAML handler and one for 
      the actual login server. (For KTH it's weblogin.kth.SAMLlogin and 
      weblogin.kth.UGlogin.) Default value is None, only the 
      `weblogin.ladok.SSOlogin` handler will be used.
    - `test_environment` specifies whether we should use LADOK's test 
      environment instead of the production environment.
    """
    self.__session = None
    <<construct the session object from the autologin handlers>>
    <<LadokSession constructor body>>

  @property
  def session(self):
    """A guaranteed to be active and logged in requests session to LADOK"""
    return self.__session

  @session.setter
  def session(self, new_value):
    self.__session = new_value

  <<LadokSession data methods>>
@

Now let's test this class.
We will use the KTH version to log in.
KTH needs the LADOK SSO handler (specifying KTH), the KTH SAML server handler 
(to handle the SSO request) and the KTH UG server (the actual login server).
<<test functions>>=
ladok = ladok3.LadokSession(
        os.environ["LADOK_INST"],
        vars={"username": os.environ["LADOK_USER"],
              "password": os.environ["LADOK_PASS"]},
        test_environment=True) # for experiments

def test_LadokSession_vars():
  assert ladok.user_info_JSON()

def test_LadokSession_autologin_handlers():
  ladok_handlers = ladok3.LadokSession(
          "KTH Royal Institute of Technology",
          autologin_handlers = [
            weblogin.kth.SAMLlogin(),
            weblogin.kth.UGlogin(os.environ["KTH_LOGIN"],
                                 os.environ["KTH_PASSWD"])
          ],
          test_environment=True) # for experiments

  assert ladok_handlers.user_info_JSON()
@


\subsection{Construct the session using [[weblogin]]}

To construct the session, we simply construct a [[weblogin.AutologinSession]] 
object.
This one requires a list of [[weblogin.AutologinHandler]] objects.

We simply pass the institution to the constructor of the 
[[weblogin.ladok.SSOlogin]] class.
We add that to the list of autologin handlers supplied by the user.
Due to the internal workings of [[weblogin.AutologinSession]], we add it first 
as a, probably negligible, optimization.
<<construct the session object from the autologin handlers>>=
if not vars:
  vars = {}
if not autologin_handlers:
  autologin_handlers = []

autologin_handlers.insert(0,
            weblogin.ladok.SSOlogin(institution, vars=vars,
                                    test_environment=test_environment))

self.__session = weblogin.AutologinSession(autologin_handlers)
@


\section{The [[LadokSession]] data methods}\label{LadokSession-data-methods}

The data methods are essentially factories for various objects mapping to data 
in LADOK.
We will first look at the base classes and then provide methods that return 
instances of various subclasses.

\subsection{LADOK data base class: [[LadokData]]}\label{LadokData}

Some objects will only have read-only attributes, like grade scales, whereas 
others, like students, will have modifiable attributes, such as results, which 
must be synced.

We will provide properties for the various attributes.
This way we can have read-only properties for attributes that cannot be 
changed, such as students' names, and read--write properties for attributes 
that can be changed, such as results.

We also want to serialize the data.
We will use the JSON format for this.
We provide this as a read only property [[json]].
If the output of [[json]] is given as the [[kwargs]] parameter to the 
[[make_properties]] method, it will restore all the attributes.

We provide the [[LadokData]] class with a constructor that takes keyword 
arguments ([[**kwargs]]).
These are not used, but just so that we can add [[super().__init__(**kwargs)]] 
at the top of every constructor of the child classes.

Thus, we have the following base class.
<<classes>>=
class LadokData:
  """Base class for LADOK data"""
  def __init__(self, /, **kwargs):
    pass

  def make_properties(self, kwargs):
    """Turn keywords into private attributes and read-only properties"""
    <<set up read-only properties>>

  def __eq__(self, other):
    if type(self) == type(other):
      return self.__dict__ == other.__dict__
    return False

  def __repr__(self):
    return str(self.json)

  @property
  def json(self):
    """JSON compatible dictionary representation of the object"""
    json_format = self.__dict__.copy()
    for key, value in json_format.items():
      if isinstance(value, LadokData):
        json_format[key] = value.json
    json_format["type"] = type(self).__name__
    return json_format
@

\subsection{To and from JSON format}

We want to be able to restore an object from that JSON formatted dictionary.
We provide a function~[[restore]], which restores an object from a JSON-like 
dictionary.
The [[restore]] function uses the constructor and, in turn, the 
[[__setup_properties]] method.
<<function>>=
def restore(json_dict):
  if "type" not in json_dict:
    return LadokData(**json_dict)

  <<check type and return such object>>

  raise TypeError(f"cannot restore type {json_dict.type}, not a known type")
@

For completeness, we also provide [[LadokDataEncoder]], a subclass of 
[[JSONEncoder]].
<<classes>>=
class LadokDataEncoder(json.JSONEncoder):
  def default(self, object):
    if isinstance(object, LadokData):
      return object.json
    return super().default(object)
@

For the [[__setup_properties]] method, we want it to set up private attributes 
and read-only properties for them.
For each keyword in [[kwargs]], we add the private attribute using 
[[setattr(self, ...)]] and the corresponding property to the class itself using 
[[setattr(type(self), ...)]].
(Note that we only add the property if it doesn't already exist.)
We check the names, if the attributes already match the pattern for a private 
attribute name, we don't \enquote{privatize} it again.
<<set up read-only properties>>=
for attribute in kwargs:
  # private attributes are named on the form _class__attribute
  priv_attr_prefix = f"_{type(self).__name__}__"
  if priv_attr_prefix in attribute:
    priv_attr_name = attribute
    property_name = attribute.replace(priv_attr_prefix, "")
  else:
    priv_attr_name = priv_attr_prefix + attribute
    property_name = attribute

  setattr(self, priv_attr_name, kwargs[attribute])
  if not hasattr(type(self), property_name):
    setattr(type(self), property_name,
      property(operator.attrgetter(priv_attr_name)))
@

\subsection{LADOK remote data base class: [[LadokRemoteData]]}%
\label{LadokRemoteData}

The objects that can be modified can also be updated.
They can be updated locally, which must be pushed to LADOK; they can be changed 
remotely, which must be pulled from LADOK.
These objects must also keep a LADOK session internally ([[self.ladok]]).
<<classes>>=
class LadokRemoteData(LadokData):
  """Base class for remote LADOK data"""
  def __init__(self, /, **kwargs):
    super().__init__(**kwargs)
    if "_LadokRemoteData__ladok" in kwargs:
      self.make_properties(**kwargs)
    else:
      self.__ladok = kwargs.pop("ladok")

  @property
  def ladok(self):
    return self.__ladok

  def pull(self):
    """Pull updates for object from LADOK"""
    raise NotImplementedError("This object doesn't support pulling from LADOK")

  def push(self):
    """Push changes made to the object to LADOK"""
    raise NotImplementedError("This object doesn't support pushing to LADOK")
@

The LADOK session object provides some methods for searching for data, \eg 
students.
These methods will return instances of [[LadokData]] or [[LadokRemoteData]].

\subsection{Cached methods}

Since the objects that can be updated can update themselves 
([[LadokRemoteData]]), we can cache the factories to speed up interaction with 
LADOK.
Since Python uses references for objects, a cached object will always be 
up-to-date if the program has made changes to it.
This way we don't have to interact with the LADOK servers for every request, 
but only when necessary.

We will have a shared cache for all methods.
<<LadokSession constructor body>>=
self.cache = {}
@ Then we can make the method caching by the following code.
\begin{minted}{python}
@cachetools.cachedmethod(
  operator.attrgetter("cache"),
  key=functools.partial(cachetools.keys.hashkey, "method"))
def method(self, *args):
  pass
\end{minted}

However, this construction cannot handle non-hashable objects (\eg dictionaries 
and lists) as arguments.
But the JSON representation of objects should be possible to make hashable.


\chapter{Helper functions}

We have several helper functions that are useful throughout.


\section{Filter on keys}

Many data methods will filter objects based on attributes.
We provide a function that takes a list of objects and a dictionary.
Each key in the dictionary corresponds to an attribute for the objects.
The value corresponding to the key, is checked for matching.

We will provide the following function, [[filter_on_keys]], which does exactly 
that.
This implementation runs through the (remaining) items once per keyword, 
meaning it's conjunctive --- all key--values must match the attribute values of 
the objects.

We use the function [[compare_values]] to compare the values, we'll get back to 
that function below.
<<functions>>=
def filter_on_keys(items, /, **kwargs):
  """
  Input:
  - items is a list of objects.
  - kwargs is a dictionary where keys match the attributes of the objects in 
    items.

  Output:
  - Only objects where *all* key--value pairs match for the corresponding 
    attribues.
  - If values are strings, the value from kwargs is interpreted as a regular 
    expression.

  Example:
  student.first_name = "Student"
  student.last_name = "Studentdotter"

  filter_on_keys([student], firt_name="Student")
    gives [student]
  filter_on_keys([student], firt_name="Student", last_name="Studentsson")
    gives []
  """
  for key in kwargs:
    items = filter(
      lambda x: compare_values(operator.attrgetter(key)(x), kwargs[key]),
      items)
  return list(items)
@

We test this function with the following tests.
<<test functions>>=
def test_filter_on_keys():
  class Object:
    pass

  student1 = Object()
  student1.first_name = "Student"
  student1.last_name = "Studentsdotter"
  student2 = Object()
  student2.first_name = "Student"
  student2.last_name = "Studentsson"

  students = [student1, student2]
  assert ladok3.filter_on_keys(students, first_name="Student") == students
  assert ladok3.filter_on_keys(students,
    first_name="Student", last_name="Studentsdotter") == [student1]
  assert ladok3.filter_on_keys(students,
    last_name="Students(dotter|son)") == students
@

To achieve disjunctive behaviour, we must run [[filter_on_keys]] once per 
keyword.
However, that causes problems if an item matches on more than one key.
The following function solves that problem by not checking an item against more 
keys once it has matched one key.
<<functions>>=
def filter_on_any_key(items, /, **kwargs):
  """
  Input:
  - items is a list of objects.
  - kwargs is a dictionary where keys match the attributes of the objects in 
    items.

  Output:
  - Only objects where *any* key--value pairs match for the corresponding 
    attribues.
  - If values are strings, the value from kwargs is interpreted as a regular 
    expression.

  Example:
  student.first_name = "Student"
  student.last_name = "Studentsdotter"

  filter_on_keys([student], firt_name="Student")
    gives [student]
  filter_on_keys([student], firt_name="Student", last_name="Studentsson")
    gives [student]
  """
  matching_items = []
  for item in items:
    for key in kwargs:
      if compare_values(operator.attrgetter(key)(item), kwargs[key]):
        matching_items.append(item)
        break

  return matching_items
@

We test this function with the following tests.
<<test functions>>=
def test_filter_on_any_key():
  class Object:
    pass

  student1 = Object()
  student1.first_name = "Student"
  student1.last_name = "Studentsdotter"
  student2 = Object()
  student2.first_name = "Student"
  student2.last_name = "Studentsson"

  students = [student1, student2]
  assert ladok3.filter_on_any_key(students,
    first_name="Student", last_name="Studentsdotter") == students
@

The function [[compare_values]] is how we compare the values.
The reason we don't simply replace it with the [[==]] operator is that for 
strings, we actually want to use regular expressions for matching.
The downside of this is that we might accidentally get substring matches when 
we expect exact matches.
\Eg \verb'F' will match both \verb'F' and \verb'Fx' unless we specify 
\verb'^F$'.
<<functions>>=
def compare_values(val1, val2):
  """
  Compares val1 and val2:
  - if val1 and val2 both are strings, then val2 is interpreted as a regular 
    expression.
  - otherwise we use ==
  """
  if isinstance(val1, str) and isinstance(val2, str):
    return re.search(val2, val1)

  return val1 == val2
@

We test this function with the following tests.
<<test functions>>=
def test_compare_values():
  assert ladok3.compare_values("Studentsdotter", "^Student")
  assert ladok3.compare_values("Studentsdotter", "dotter")
  assert not ladok3.compare_values("Studentsdotter", "son")
  assert ladok3.compare_values(1, 1)
  assert not ladok3.compare_values(1, 2)
@


\section{Extracting translations}

In many cases, LADOK provides several translations.
They do that in the form of this JSON structure:
\begin{minted}{JSON}
{
  "Benamning": [
    {
      "Sprakkod": "sv",
      "Text": "Laborationer",
      "link": []
    },
    {
      "Sprakkod": "en",
      "Text": "Programming Assignments",
      "link": []
    }
  ]
}
\end{minted}
We provide the function [[get_translation]] to get the [[Text]] based on a 
specified [[Sprakkod]].
<<functions>>=
def get_translation(lang_code, list_of_translations):
  for translation in list_of_translations:
    if translation["Sprakkod"] == lang_code:
      return translation["Text"]
  raise KeyError(f"no translation for language {lang_code}")
@


\chapter{Grading scales}

LADOK has various grading scales.
Whenever we deal with results, we must use them and their identifiers.
We provide classes that wraps LADOK's grading scales: [[GradeScale]] and 
[[Grade]].
We also provide a method, [[get_grade_scales]], which returns a list of 
[[GradeScale]] objects.


\section{The [[get_grade_scales]] method}

We start with the method that returns the grading-scales objects.
This method interacts with LADOK, so we want to cache its responses.
We also want to be able to filter the responses, we do this by keyword 
arguments.
<<LadokSession data methods>>=
@cachetools.cachedmethod(
  operator.attrgetter("cache"),
  key=functools.partial(cachetools.keys.hashkey, "grade_scale"))
def get_grade_scales(self, /, **kwargs):
  """Return a list of (un)filtered grade scales"""
  if len(kwargs) == 0:
    return [GradeScale(**scale_data)
              for scale_data in self.grade_scales_JSON()]

  return filter_on_keys(self.get_grade_scales(), **kwargs)
@

The [[grade_scales_JSON]] method is part of the LADOK API and is documented in 
\cref{GradeScalesJSON}.


\section{The [[GradeScale]] and [[Grade]] classes}

We need a class for grade scales.
This object should be read only and we never need to update it, so we can base 
it on [[LadokData]].
[[kwargs]] will have the following format:
\begin{pycode}
import json
import ladok3
import os

ladok = ladok3.LadokSession(
          os.environ["LADOK_INST"],
          vars={"username": os.environ["LADOK_USER"],
                "password": os.environ["LADOK_PASS"]},
          test_environment=True)

print(r"\begin{minted}{JSON}")
print(json.dumps(ladok.grade_scales_JSON()[0], indent=2))
print(r"\end{minted}")
\end{pycode}

This makes the follow class design suitable.
<<classes>>=
class GradeScale(LadokData):
  """A grade scale"""
  def __init__(self, /, **kwargs):
    super().__init__(**kwargs)

    if "_GradeScale__id" in kwargs:
      self.make_properties(**kwargs)
    else:
      self.__id = int(kwargs.pop("ID"))
      self.__code = kwargs.pop("Kod")
      self.__name = kwargs.pop("Benamning")["sv"]
      self.__grades = [Grade(**grade_data)
                        for grade_data in kwargs.pop("Betygsgrader")]

  @property
  def id(self):
    return self.__id

  @property
  def code(self):
    return self.__code

  @property
  def name(self):
    return self.__name

  def grades(self, /, **kwargs):
    """Returns grades filtered on keyword"""
    return filter_on_keys(self.__grades, **kwargs)

  def __contains__(self, grade):
    <<test if grade is in grading scale>>

  def __iter__(self):
    <<iterate over grades in grading scale>>
@

Then we need a class for the grades themselves.
We construct a grade from the LADOK JSON data.
We also implement easy comparison so that we can search for the string 
\enquote{A} instead of the [[Grade]] object for the A grade.
<<classes>>=
class Grade(LadokData):
  """An individual grade part of a grade scale"""
  def __init__(self, /, **json_data):
    """Constructor taking a dictionary (JSON-like) structure"""
    if "_Grade__id" in json_data:
      self.make_properties(**json_data)
    else:
      self.__id = int(json_data.pop("ID"))
      self.__code = json_data.pop("Kod")
      self.__accepted = json_data.pop("GiltigSomSlutbetyg")

  @property
  def id(self):
    return self.__id

  @property
  def code(self):
    return self.__code

  def __str__(self):
    return self.code

  @property
  def accepted(self):
    return self.__accepted

  def __eq__(self, other):
    if isinstance(other, Grade):
      return self.__dict__ == other.__dict__
    elif isinstance(other, str):
      return self.code == other
    else:
      raise NotImplementedError(f"can't test equality with {type(other)}")
@


\paragraph{Checking if a grade is in a grading scale}

We can now easily implement the check if a grade is in a grading scale.
<<test if grade is in grading scale>>=
return grade in self.__grades
@ This works even if [[grade]] is a string, thanks to how [[__eq__]] is 
implemented in the [[Grade]] class.

Similarly, we can iterate over the grades in the grading scale.
<<iterate over grades in grading scale>>=
return iter(self.__grades)
@



\chapter{Students}\label{StudentClasses}

This chapter treats how we can work with student data.
We can get student data from LADOK using the [[LadokSession]] class.
We first create the [[ladok]] object, an instance of a LADOK session.
\inputminted[lastline=6]{python}{../examples/example_Student.py}
This is the same as in \cref{AccessingLADOK}.

Next we want to access data of a student.
We can refer to the student by personnummer or the unique LADOK ID.
\inputminted[firstline=8,lastline=13]{python}{../examples/example_Student.py}
This gives us objects of the [[Student]] class.
The objects [[me]] and [[me2]] both refer to the same person, so the outputs 
should be the same.

We can see which course instances the student is registered on (throughout 
history).
\inputminted[firstline=16,lastline=17]{python}{../examples/example_Student.py}
We can select a particular course and we can get the results for that course in 
the same way.
\inputminted[firstline=19,lastline=29]{python}{../examples/example_Student.py}
We can check if the result is attested or not.
If it's not attested, we can change it.
\inputminted[firstline=32,lastline=51]{python}{../examples/example_Student.py}


\section{Getting students from LADOK}\label{GetStudent}

Perhaps the main data that we want to access is that of a student.
We provide two ways to identify the student.
The personal identity number (Swedish 
\emph{\foreignlanguage{swedish}{personnummer}}) and the unique LADOK 
identifier.
These are so different in format that we can distinguish one from the other.
However, we an delegate this job to the [[Student]] class.
<<LadokSession data methods>>=
@cachetools.cachedmethod(
  operator.attrgetter("cache"),
  key=functools.partial(cachetools.keys.hashkey, "get_student"))
def get_student(self, id):
  """Get a student by unique ID, returns a Student object"""
  # note that self is the required LadokSession object
  return Student(ladok=self, id=id)
@


\section{The [[Student]] class}

We can create a [[Student]] object from an identifier and a [[LadokSession]] 
object.
Then the [[Student]] object can fetch data from LADOK and update any changes.

We can determine if an identifier is a personnummer or LADOK ID.
Based on either of those unique identifiers we can fetch the rest of the data 
using the LADOK session~[[self.ladok]].
<<classes>>=
class Student(LadokRemoteData):
  """Class representing a student and related data"""
  def __init__(self, /, **kwargs):
    """Requires ladok (a LadokSession object),
    id (either a personnummer or LADOK ID)"""
    super().__init__(**kwargs)
    id = kwargs.pop("id")
    self.__personnummer = format_personnummer(id)
    if not self.__personnummer:
      self.__ladok_id = id
    else:
      self.__ladok_id = None

  def pull(self):
    """pull student data from LADOK"""
    <<pull all attributes from LADOK>>

  <<student attribute methods>>
@

We use the function [[format_personnummer]] to format a personnummer according 
to LADOK's requirements.
This function returns [[None]] if it's not a personnummer, in which case we 
assume that it is a LADOK ID in the code above.
<<functions>>=
def format_personnummer(person_nr_raw):
  """Returns None or a LADOK-formated person nr"""
  pnrregex = re.compile(r"^(\d\d)?(\d\d)(\d\d\d\d)[+\-]?(\w\w\w\w)$")
  pnr = pnrregex.match(person_nr_raw)
  if pnr:
    now = datetime.datetime.now()
    if pnr.group(1) == None: # first digits 19 or 20 missing
      if now.year - 2000 >= int(pnr.group(2)) + 5: # must be > 5 years old
        return "20" + pnr.group(2) + pnr.group(3) + pnr.group(4)
      else:
        return "19" + pnr.group(2) + pnr.group(3) + pnr.group(4)
    else:
      return pnr.group(1) + pnr.group(2) + pnr.group(3) + pnr.group(4)
  else:
    return None
@ Note that we must match the start and end in the regex, otherwise we 
sometimes match parts of LADOK IDs as personnummer.

\section{Students' personal attributes}

The student's personal attributes are the following.
We use the helper method [[__get_personal_attributes]] which pulls all personal 
attributes, since LADOK returns all of these in one call.
<<student attribute methods>>=
def __get_personal_attributes(self):
  """Helper method that fetches personal attributes"""
  <<pull student attributes from LADOK>>

@property
def ladok_id(self):
  """Return the student's LADOK ID"""
  try:
    if self.__ladok_id:
      return self.__ladok_id
  except:
    pass
  self.__get_personal_attributes()
  return self.__ladok_id

@property
def personnummer(self):
  """Return the student's personnummer"""
  try:
    if self.__personnummer:
      return self.__personnummer
  except:
    pass
  self.__get_personal_attributes()
  return self.__personnummer

@property
def first_name(self):
  """Return the student's first name"""
  try:
    return self.__first_name
  except:
    self.__get_personal_attributes()
  return self.__first_name

@property
def last_name(self):
  """Return the student's last name"""
  try:
    return self.__last_name
  except:
    self.__get_personal_attributes()
  return self.__last_name

def __str__(self):
  return f"{self.personnummer} {self.first_name} {self.last_name}"

@property
def alive(self):
  """Return whether student is alive or not"""
  try:
    return self.__alive
  except:
    self.__get_personal_attributes()
  return self.__alive
@

Then we can call that method to update all attributes.
<<pull all attributes from LADOK>>=
self.__get_personal_attributes()
@

When we pull the student attributes from LADOK, we can use either of the two 
IDs: [[self.personnummer]] and [[self.ladok_id]].
(However, we avoid using the properties above in this code, since we don't want 
to recursively trigger the fetch ad absurdum.)
Depending on which attribute is set, we pull the data differently.
<<pull student attributes from LADOK>>=
if self.__ladok_id:
  record = self.ladok.get_student_data_by_uid_JSON(self.__ladok_id)
elif self.__personnummer:
  record = self.ladok.get_student_data_JSON(self.__personnummer)
else:
  raise AttributeError("neither personnummer, nor LADOK ID set")

self.__ladok_id = record['Uid']
self.__personnummer = record['Personnummer'] # twelve digits only
self.__first_name = record['Fornamn']
self.__last_name = record['Efternamn']
self.__alive = not record['Avliden']
@


\section{Students' study-related attributes}

The study related attributes are courses and course results.
Similarly to above, we use the [[__get_study_attributes]] helper method to 
populate all study-related attributes that LADOK returns in one request.
<<student attribute methods>>=
def __get_study_attributes(self):
  """Helper method to fetch study related attributes"""
  <<create a list of the student's course objects>>

def courses(self, /, **kwargs):
  """
  Returns a list of courses that the student is registered on.
  Filtered based on keywords, see ladok3.filter_on_keys for details.
  """
  try:
    courses = self.__courses
  except:
    self.__get_study_attributes()
    courses = self.__courses

  return filter_on_keys(courses, **kwargs)
@

Then we can call the last method when we want to pull all attributes too (using 
the [[pull]] method).
<<pull all attributes from LADOK>>=
self.__get_study_attributes()
@

To create a list of the student's course registrations, we use the 
[[registrations_JSON]] API method.
<<create a list of the student's course objects>>=
self.__courses = []

for course in self.ladok.registrations_JSON(self.ladok_id):
  if not course['Nuvarande'] or \
    'Utbildningskod' not in course['Utbildningsinformation']:
    continue
  
  self.__courses.append(CourseRegistration(
    ladok=self.ladok,
    student=self,
    **course["Utbildningsinformation"]))
@


\section{Is the student suspended?}

We also want to know if a student is suspended or not.
We can get a list of suspensions for a student.
However, since suspended students are rare, we haven't found a specimen to 
study; so we simply don't know what the list contains.
But we can return it nonetheless.
We never cache this result since we always want the most up-to-date version.
<<student attribute methods>>=
@property
def suspensions(self):
  """
  The list of the students' suspensions.
  """
  return self.ladok.get_student_suspensions_JSON(self.ladok_id)["Avstangning"]
@


\chapter{Courses}\label{CourseClasses}

We can use the course-related classes as follows.
\inputminted{python}{../examples/example_Course.py}

\section{Course rounds}

We can search for courses like this.
The result consists of a list of [[CourseRound]] objects.
<<LadokSession data methods>>=
@cachetools.cachedmethod(
  operator.attrgetter("cache"),
  key=functools.partial(cachetools.keys.hashkey, "search_courses"))
def search_course_rounds(self, /, **kwargs):
  """Query LADOK about course rounds, possible keys:
  code, round_code, name
  """
  results = self.search_course_rounds_JSON(**kwargs)
  return [CourseRound(ladok=self, **result) for result in results]
@

The response consists of this JSON data:
\begin{pycode}
import json
import ladok3
import os

ladok = ladok3.LadokSession(
          os.environ["LADOK_INST"],
          vars={"username": os.environ["LADOK_USER"],
                "password": os.environ["LADOK_PASS"]},
          test_environment=True)

print(r"\begin{minted}{JSON}")
prgi = ladok.search_course_rounds_JSON(code="DD1317")[0]
ladok3.clean_data(prgi)
print(json.dumps(prgi, indent=2))
print(r"\end{minted}")
\end{pycode}

We have two classes that are relevant here, [[CourseInstance]] and 
[[CourseRound]].
The [[CourseInstance]] corresponds to the data in [[Utbildningsinstans]] above.
And the [[CourseRound]] is the data \enquote{wrapping around} that of the 
[[CourseInstance]].
Thus, we will make [[CourseRound]] a specialization of [[CourseInstance]].
This makes sense as it contains additional data, such as start and end date.
This class takes care of those and then defers the rest to the 
[[CourseInstance]] class (by calling its constructor).
<<classes>>=
class CourseInstance(LadokRemoteData):
  """Represents a course instance. Must be constructed from at least
  ladok (a LadokSession object),
  UtbildningsinstansUID (an instance_id from LADOK),
  optionally a data dictionary from LADOK"""
  <<CourseInstance methods>>

class CourseRound(CourseInstance):
  """Represents a course round"""
  def __init__(self, /, **kwargs):
    """
    Must be constructed from at least:
    Uid, TillfallesKod, Startdatum, Slutdatum
    """
    self.__round_id = kwargs.pop("Uid")
    self.__round_code = kwargs.pop("TillfallesKod")

    self.__start = datetime.date.fromisoformat(kwargs.pop("Startdatum"))
    self.__end = datetime.date.fromisoformat(kwargs.pop("Slutdatum"))

    <<prepare kwargs and call CourseInstance constructor>>

  @property
  def round_id(self):
    return self.__round_id

  @property
  def round_code(self):
    return self.__round_code

  @property
  def start(self):
    return self.__start

  @property
  def end(self):
    return self.__end

  <<CourseRound data methods>>
@

The [[CourseInstance]] constructor expects only the [[Utbildningsinstans]] part 
of the data.
However, the [[Uid]] should be renamed [[UtbildningsinstansUID]].
We must also pass on the [[ladok]] object.
<<prepare kwargs and call CourseInstance constructor>>=
instance_data = kwargs.pop("Utbildningsinstans")
instance_data["UtbildningsinstansUID"] = instance_data.pop("Uid")
super().__init__(ladok=kwargs.pop("ladok"), **instance_data)
@

\section{Course instances}

We have the course instance as the base class.
This is essentially an \enquote{instance of a course syllabus}.
We know from above that it inherits from [[LadokRemoteData]] and that it must 
be initialized with the keywords [[ladok]] (for its parent) and 
[[UtbildningsinstansUID]] (for itself) and optionally some data.
<<CourseInstance methods>>=
def __init__(self, /, **kwargs):
  self.__instance_id = kwargs.pop("UtbildningsinstansUID")
  super().__init__(**kwargs) # sets self.ladok

  <<CourseInstance constructor body>>
@

We can fetch the data from LADOK as follows.
Note that we need to use the [[round_id]] from the [[CourseRound]] object.
This works since we never have a [[CourseInstance]] object on its own, it's 
always parent of a [[CourseRound]] object.
(And that makes this kind of ugly from an OOP perspective.)
<<fetch CourseInstance data from LADOK>>=
data = self.ladok.course_round_components_JSON(self.round_id)
@

Then data will be populated with the following values:
\begin{pycode}
import json
import ladok3
import os

ladok = ladok3.LadokSession(
          os.environ["LADOK_INST"],
          vars={"username": os.environ["LADOK_USER"],
                "password": os.environ["LADOK_PASS"]},
          test_environment=True)

print(r"\begin{minted}{JSON}")
data = ladok.course_round_components_JSON(
                  "cf7045a7-3e1c-11eb-b960-5f936a674375")
ladok3.clean_data(data)
print(json.dumps(data, indent=2))
print(r"\end{minted}")
\end{pycode}

Now that we have all data in [[data]], we can assign its values to the private 
attributes.
We note, however, that some course instances lack both [[Versionsnummer]] and 
[[Omfattning]].
It seems like faux courses are created to document when students go on 
Exchanges.
These faux courses have a name and code, but no credits or version of syllabus.
Consequently they don't have any grading scales either.

Our approach will be to try to assign the attributes using [[kwargs]], and if 
that fails, we will fetch the data (pull from LADOK).
If that pull fails with missing data, then we will assume that it's one of 
these faux courses.
<<CourseInstance constructor body>>=
try:
  self.__assign_attr(kwargs)
except:
  self.__pull_attributes()
<<CourseInstance methods>>=
def __assign_attr(self, data):
  <<assign CourseInstance data to private attributes>>

def __pull_attributes(self):
  <<fetch CourseInstance data from LADOK>>
  try:
    self.__assign_attr(data)
  except:
    self.__assign_faux(data)

def pull(self):
  self.__pull_attributes()

def __assign_faux(self, data):
  <<assign faux CourseInstance data to private attributes>>
@

By trial-and-error, it seems like the faux courses has none of the attributes 
that the real courses have.
However, we try our best.
<<assign common CourseInstance data to private attributes>>=
self.__components = []
<<add course components to [[self.__components]]>>
<<assign CourseInstance data to private attributes>>=
<<assign common CourseInstance data to private attributes>>

self.__name = data.pop("Benamning")
self.__code = data.pop("Utbildningskod")

self.__credits = data.pop("Omfattning")
self.__unit = data.pop("Enhet")

self.__version = data.pop("Versionsnummer")

self.__education_id = data.pop("UtbildningUID")

self.__grade_scale = self.ladok.get_grade_scales(
  id=data.pop("BetygsskalaID"))
<<assign faux CourseInstance data to private attributes>>=
<<assign common CourseInstance data to private attributes>>

self.__name = data.pop("Benamning", None)
self.__code = data.pop("Utbildningskod", None)

self.__credits = data.pop("Omfattning", None)
self.__unit = data.pop("Enhet", None)

self.__version = data.pop("Versionsnummer", None)

self.__education_id = data.pop("UtbildningUID", None)

try:
  self.__grade_scale = self.ladok.get_grade_scales(
    id=data.pop("BetygsskalaID"))
except KeyError:
  self.__grade_scale = None
@

Finally, we want to have properties to access the private attributes.
<<CourseInstance methods>>=
@property
def instance_id(self):
  return self.__instance_id

@property
def education_id(self):
  return self.__education_id

@property
def code(self):
  return self.__code

@property
def name(self):
  return self.__name["en"]

@property
def version(self):
  return self.__version

@property
def grade_scale(self):
  return self.__grade_scale

@property
def credits(self):
  return self.__credits

@property
def unit(self):
  return self.__unit

def components(self, /, **kwargs):
  """Returns the list of components, filtered on keywords"""
  return filter_on_keys(self.__components, **kwargs)
@


\subsection{Course components}

We need to add the courses components to the course instance.
That is things like LAB1 or EXA1 that make up the course in LADOK.
<<add course components to [[self.__components]]>>=
if "IngaendeMoment" in data:
  self.__components += [CourseComponent(
      ladok=self.ladok, course=self,
      **component) for component in data["IngaendeMoment"]]
@

We also add the course itself as a component.
This is to handle the grade on the course itself.
Once all the components have a grade, the course itself will get a grade.
This component represents that grade.
It will get the course code as its code.
<<add course components to [[self.__components]]>>=
try:
  course_component_data = data.copy()
  course_component_data["ladok"] = self.ladok
  self.__components.append(CourseComponent(course=self,
                                           **course_component_data))
except KeyError:
  pass
@


\section{Course components}

The [[CourseComponent]] class will make the attributes available.
We specify the most interesting ones and let the [[LadokData]] constructor turn 
the rest into properties as well, so that they are available for the curious.

Turns out that some course components don't have any credits.
This is probably a consequence of being a component in a course with no 
credits, \eg one of those faux courses to register exchange studies.
<<classes>>=
class CourseComponent(LadokData):
  """Represents a course component of a course registration"""
  def __init__(self, /, **kwargs):
    super().__init__(**kwargs)

    self.__course = kwargs.pop("course")

    if "UtbildningsinstansUID" in kwargs:
      self.__instance_id = kwargs.pop("UtbildningsinstansUID")
    else:
      self.__instance_id = kwargs.pop("Uid")

    self.__education_id = kwargs.pop("UtbildningUID")

    self.__code = kwargs.pop("Utbildningskod")
    description = kwargs.pop("Benamning")
    if isinstance(description, dict):
      self.__description = description["sv"]
    else:
      self.__description = description

    self.__credits = kwargs.pop("Omfattning", None)
    self.__unit = kwargs.pop("Enhet", None)

    ladok = kwargs.pop("ladok")
    grade_scale_id = kwargs.pop("BetygsskalaID")
    self.__grade_scale = ladok.get_grade_scales(id=grade_scale_id)[0]

  @property
  def course(self):
    return self.__course

  @property
  def instance_id(self):
    return self.__instance_id

  @property
  def education_id(self):
    return self.__education_id

  @property
  def code(self):
    """Returns the name of the component (as in syllabus)"""
    return self.__code

  @property
  def description(self):
    """Returns description of component (as in syllabus)"""
    return self.__description

  @property
  def unit(self):
    """Returns the unit for the credits"""
    return self.__unit

  @property
  def credits(self):
    """Returns the number of credits"""
    return self.__credits

  @property
  def grade_scale(self):
    return self.__grade_scale

  def __str__(self):
    return self.code

  def __eq__(self, other):
    if isinstance(other, str):
      return self.code == other
    return self.__dict__ == other.__dict__
@ We have the latter method, [[__eq__]], so that we can filter on keys and 
compare with strings.


\section{Results for a course round}

We can access the results of all the students during a course round.
We do this through the method [[results]], which takes keyword arguments to 
possibly filter the results.
<<CourseRound data methods>>=
def results(self, /, **kwargs):
  """Returns all students' results on the course"""
  try:
    self.__results
  except:
    self.__fetch_results()

  return filter_on_keys(self.__results, **kwargs)
@

To fetch the results from LADOK, we must do the following query.
<<CourseRound data methods>>=
def __fetch_results(self):
  raise NotImplementedError(
    f"{type(self).__name__}.__fetch_results not implemented")
@


\section{Participants for a course round}

We want to get a list of participants for a course round, \ie a list of 
[[Student]] objects.
<<CourseRound data methods>>=
def participants(self, /, **kwargs):
  """Returns a Student object for each participant in the course."""
  try:
    self.__participants
  except:
    self.__fetch_participants()

  return filter_on_keys(self.__participants, **kwargs)
@

When we fetch the participants, we don't create new [[Student]] objects.
We use the [[get_student]] method of the LADOK session object to fetch objects 
from the cache if they already exist.
<<CourseRound data methods>>=
def __fetch_participants(self):
  self.__participants = []
  for student in self.ladok.participants_JSON(self.round_id):
    self.__participants.append(
      self.ladok.get_student(student["Student"]["Uid"]))
@


\chapter{Course objects related to students}

\section{Course registrations and a student's results}

Students register for a course.
The [[CourseRegistration]] class represents this data from LADOK.
This is the object that must be used to get results for a student.
This object keeps more info than the course instance.

We note that some registrations lack the \enquote{Utbildningstillfalleskod} 
attribute.
This happens on \enquote{custom courses} like Erasmus exchanges.
If that's the case, we use the value [[None]] in its place.
<<classes>>=
class CourseRegistration(CourseInstance):
  """Represents a student's participation in a course instance"""
  def __init__(self, /, **kwargs):
    self.__student = kwargs.pop("student")

    # ett Ladok-ID för kursomgången
    self.__round_id = kwargs.pop("UtbildningstillfalleUID")
    self.__round_code = kwargs.pop("Utbildningstillfalleskod", None)

    dates = kwargs.pop("Studieperiod")
    self.__start = datetime.date.fromisoformat(dates["Startdatum"])
    self.__end = datetime.date.fromisoformat(dates["Slutdatum"])

    super().__init__(**kwargs)

  @property
  def round_id(self):
    """Returns LADOK ID for the course round (kursomgång)"""
    return self.__round_id

  @property
  def round_code(self):
    """Returns the human-readable round code (tillfälleskod)"""
    return self.__round_code

  @property
  def start(self):
    return self.__start

  @property
  def end(self):
    return self.__end

  def __str__(self):
    return f"{self.code} {self.round_code or ''} ({self.start}--{self.end})"

  def __repr__(self):
    return f"{self.code}:{self.round_code or ''}:{self.start}--{self.end}"

  def results(self, /, **kwargs):
    """Returns the student's results on the course, filtered on keywords"""
    try:
      return filter_on_keys(self.__results, **kwargs)
    except:
      self.__fill_results()
    return filter_on_keys(self.__results, **kwargs)

  def __fill_results(self):
    """Helper method to fetch results from LADOK"""
    <<pull existing CourseResult objects from LADOK>>
    <<add new CourseResult objects for missing components>>

  def push(self):
    """Pushes any new results"""
    for result in self.results():
      result.push()
@

We can pull these from LADOK as well.
We construct [[CourseResult]] objects using a [[CourseRegistration]] object.
From the response we get from LADOK, we construct [[CourseResult]] objects that 
deal with the details.
(It's a bit unclear why [[Kursversioner]] is a list, so far it has always 
worked to take the first.)
<<pull existing CourseResult objects from LADOK>>=
response = self.ladok.student_results_JSON(
  self.__student.ladok_id, self.education_id
)["Kursversioner"][0]

self.__results = []

for result in response["VersionensModuler"]:
  try:
    self.__results.append(CourseResult(ladok=self.ladok,
                                       components=self.components(),
                                       student=self.__student,
                                       **result))
  except TypeError:
    pass
@

As with the components, the course grade itself is a special case.
That data is not in [[VersionensModuler]], but in [[VersionensKurs]].
But we can do the same with it, just as we could with the components.
(And this works since it's a component in [[self.components()]].)
<<pull existing CourseResult objects from LADOK>>=
try:
  self.__results.append(CourseResult(ladok=self.ladok,
                                     components=self.components(),
                                     student=self.__student,
                                     **response["VersionensKurs"]))
except TypeError:
  pass
@

Now we can see which components from [[self.components]] are missing from 
[[self.__results]] and just add empty results for those.
<<add new CourseResult objects for missing components>>=
for component in self.components():
  if not list(filter_on_keys(self.__results, component=component.code)):
    self.__results.append(
      CourseResult(
        ladok=self.ladok,
        component=component,
        student=self.__student))
@


\section{Course results}

The [[CourseResult]] objects have the following form.
We have two cases: the result exists in LADOK and the result doesn't exist in 
LADOK.
The difference is in how results are pushed to LADOK, \ie the implementation of 
the [[push]] method.
<<classes>>=
class CourseResult(LadokRemoteData):
  """Represents a result on a course module"""
  def __init__(self, /, **kwargs):
    """To construct this object we must give existing data, i.e.
    Arbetsunderlag or SenastAttesteradeResultat directly from LADOK."""
    super().__init__(**kwargs)

    self.__student = kwargs.pop("student")

    self.__attested = False
    if "component" in kwargs:
      self.__component = kwargs.pop("component")
      self.__populate_attributes()
    elif "components" in kwargs and "ResultatPaUtbildning" in kwargs:
      components = kwargs.pop("components")

      results = kwargs.pop("ResultatPaUtbildning")

      if "Arbetsunderlag" in results:
        data = results["Arbetsunderlag"]
      elif "SenastAttesteradeResultat" in results:
        self.__attested = True
        data = results["SenastAttesteradeResultat"]
      else:
        data = kwargs

      self.__populate_attributes(**data, components=components)
    else:
      raise TypeError("not enough keys given to construct object")

  def __populate_attributes(self, /, **data):
    if not data:
      <<populate CourseResult attributes for empty result>>
    else:
      <<populate CourseResult attributes from data>>

  @property
  def component(self):
    """Returns the component the results is for"""
    return self.__component

  @property
  def grade_scale(self):
    """Returns the grade scale for the component"""
    return self.__grade_scale

  @property
  def grade(self):
    """Returns the grade set for the component"""
    return self.__grade

  def set_grade(self, grade, date):
    """Sets a new grade and date for the component"""
    if self.attested:
      raise AttributeError("can't change already attested grade")

    <<set the grade for CourseResult>>

    self.__modified = True
    self.push()

  def finalize(self, graders=[], notify=False):
    """Finalizes the set grade"""
    if self.modified:
      self.push()

    <<finalize the grade for CourseResult>>

  @property
  def modified(self):
    """Returns True if there are unpushed changes"""
    return self.__modified

  @property
  def date(self):
    """Returns the date of the grade"""
    return self.__date

  @property
  def attested(self):
    """Returns True if the grade has been attested in LADOK"""
    return self.__attested

  def __str__(self):
    return f"{self.component} {self.grade} " \
           f"{self.date}{'*' if not self.attested else ''}"

  def push(self):
    if self.__uid:
      <<push the existing CourseResult grade data to LADOK>>
    else:
      <<push the new CourseResult grade data to LADOK>>
    self.__modified = False
@

If we get the data from LADOK, then we can fill in all the attributes.
<<populate CourseResult attributes from data>>=
self.__uid = data.pop("Uid", None)
self.__instance_id = data.pop("UtbildningsinstansUID")
self.__results_id = data.pop("ResultatUID", None)
self.__study_results_id = data.pop("StudieresultatUID", None)

try:
  grade = data.pop("Betygsgrad", None)
  grade_scale_id = data.pop("BetygsskalaID")
except KeyError:
  grade_scale_id = int(data["Betygsskala"]["ID"])

self.__date = data.pop("Examinationsdatum", None)
self.__grade_scale = self.ladok.get_grade_scales(id=grade_scale_id)[0]
if grade:
  self.__grade = self.__grade_scale.grades(id=grade)[0]
else:
  self.__grade = None

if "components" in data:
  components = data.pop("components")
  component_list = filter_on_keys(components, instance_id=self.__instance_id)
  self.__component = component_list[0] if component_list \
                                       else None

self.__last_modified = data.pop("SenasteResultatandring", None)
self.__modified = False
@

However, if this is a completely new result, it doesn't exist in LADOK.
Then we lack quite a few of the attributes.
<<populate CourseResult attributes for empty result>>=
self.__uid = None
self.__instance_id = self.__component.instance_id

self.__date = None
self.__grade_scale = self.__component.grade_scale
self.__grade = None

self.__modified = False
self.__last_modified = None
@

\subsection{Setting the grade}

We can accept the grade either as a grade object or as a string.
We must check both values for correctness before we update either of the 
attributes --- otherwise we might end up in an inconsistent state.
<<set the grade for CourseResult>>=
if isinstance(grade, Grade) and grade not in self.grade_scale.grades():
  raise TypeError(f"The grade {grade} is not in"
    f"the scale {self.grade_scale.code}")
elif isinstance(grade, str):
  try:
    grade = self.grade_scale.grades(code=grade)[0]
  except:
    raise TypeError(
      f"The grade {grade} is not in the scale {self.grade_scale.code}")
else:
  raise TypeError(f"Can't use type {type(grade)} for grade")

if isinstance(date, str):
  date = datetime.date.fromisoformat(date)
elif not isinstance(date, datetime.date):
  raise TypeError(f"Type {type(date)} not supported for date")

self.__grade = grade
self.__date = date
@


\subsection{Working with existing results}

To push an updated result to LADOK, we do the following.
<<push the existing CourseResult grade data to LADOK>>=
try:
  response = self.ladok.update_result_JSON(
    self.__uid, self.grade.id, self.date.isoformat(), self.__last_modified
  )
except Exception as err:
  raise Exception(
    f"couldn't update {self.component.code} to {self.grade} ({self.date})"
    f" to LADOK: {err}"
  )

self.__populate_attributes(**response)
@

\subsection{Adding new results}

We treat new results differently.
Since we don't update an already existing item, we must add a new result to 
LADOK.
Particularly, we must add something to the student's study results.
<<push the new CourseResult grade data to LADOK>>=
try:
  response = self.ladok.create_result_JSON(
    self.__student.ladok_id,
    self.__component.course.instance_id,
    self.__component.instance_id,
    self.grade.id, self.date.isoformat()
  )
except Exception as err:
  raise Exception("Couldn't register "
    f"{self.component} {self.grade} {self.date}: {err}")

self.__populate_attributes(**response)
@


\subsection{Finalizing a result}

When we finalize the result, we must know who reported the result.
<<finalize the grade for CourseResult>>=
reporter_id = self.ladok.user_info_JSON()["AnvandareUID"]

if notify:
  response = self.ladok.finalize_result_JSON(
    self.__results_id, self.__last_modified, reporter_id, reporter_id,
    others=graders
  )
else:
  response = self.ladok.finalize_result_JSON(
    self.__results_id, self.__last_modified, reporter_id,
    others=graders
  )

self.__populate_attributes(**response)
@
